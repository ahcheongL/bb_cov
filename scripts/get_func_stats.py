#!/usr/bin/env python3
import os, sys, glob, tqdm
import json


class FuncStat:
    def __init__(self):
        self.num_calls = 0  # Total number of calls to this function
        self.num_covered = 0  # Number of inputs that covered this function
        self.sum_first_call_rel_pos = 0  # Sum of relative positions of first call
        self.sum_first_return_rel_pos = 0  # Sum of relative positions of first return
        self.sum_last_call_rel_pos = 0  # Sum of relative positions of last call

    def to_dict(self):
        return {
            "num_calls": self.num_calls,
            "num_covered": self.num_covered,
            "avg_num_calls_per_input": (
                self.num_calls / self.num_covered if self.num_covered > 0 else None
            ),
            "avg_first_call_rel_pos": (
                (self.sum_first_call_rel_pos / self.num_covered)
                if self.num_covered > 0
                else None
            ),
            "avg_first_return_rel_pos": (
                (self.sum_first_return_rel_pos / self.num_covered)
                if self.num_covered > 0
                else None
            ),
            "avg_last_call_rel_pos": (
                (self.sum_last_call_rel_pos / self.num_covered)
                if self.num_covered > 0
                else None
            ),
        }


class FuncStatEncoder(json.JSONEncoder):
    def default(self, o):
        if isinstance(o, FuncStat):
            return o.to_dict()
        return super().default(o)


def get_func_stats(seq_files: list[str], seq_dir: str, output_fn: str | None):
    result = dict()
    for fn in tqdm.tqdm(seq_files):
        full_fn = f"{seq_dir}/{fn}"
        if not os.path.isfile(full_fn):
            continue

        func_call_set = set()
        func_ret_set = set()

        last_call_dict = dict()

        with open(full_fn, "r") as f:
            num_lines = sum(1 for _ in f)
            f.seek(0)

            for idx, line in enumerate(f):
                line = line.strip()
                if line == "":
                    continue
                parts = line.split(" ")
                if len(parts) != 2:
                    continue
                func_name = parts[0]
                func_type = parts[1]

                if func_name not in result:
                    result[func_name] = FuncStat()

                func_stat = result[func_name]

                is_call = func_type == "ENTRY" or func_type == "EXTERNAL"

                rel_pos = idx / num_lines

                if is_call:
                    func_stat.num_calls += 1
                    last_call_dict[func_name] = rel_pos

                if is_call and func_name not in func_call_set:
                    func_stat.sum_first_call_rel_pos += rel_pos
                    func_call_set.add(func_name)
                elif not is_call and func_name not in func_ret_set:
                    func_stat.sum_first_return_rel_pos += rel_pos
                    func_ret_set.add(func_name)

        for func_name in func_call_set:
            func_stat = result[func_name]
            func_stat.num_covered += 1

        for func_name, rel_pos in last_call_dict.items():
            func_stat = result[func_name]
            func_stat.sum_last_call_rel_pos += rel_pos

    if output_fn is not None:
        with open(output_fn, "w") as out_f:
            json.dump(result, out_f, cls=FuncStatEncoder, indent=2)


def main(argv):
    if len(argv) < 2:
        print(f"Usage: {argv[0]} <seq_output_dir> [<output.json>]")
        print("  It computes func seq statistics from func seq output files.")
        print(
            "  <seq_output_dir>: Directory containing func seq output files generated by func_seq_rt.cc"
        )
        print(
            "  <output.json>: (Optional) Output file name to save function call statistics as JSON"
        )
        return 1

    seq_dir = argv[1]
    if not os.path.exists(seq_dir) or not os.path.isdir(seq_dir):
        print(f"Seq dir {seq_dir} does not exist or is not a directory")
        return 1

    output_fn = None
    if len(argv) >= 3:
        output_fn = argv[2]

    seq_files = os.listdir(seq_dir)
    if len(seq_files) == 0:
        print(f"No seq output files found in {seq_dir}")
        return 1

    get_func_stats(seq_files, seq_dir, output_fn)

    return 0


if __name__ == "__main__":
    sys.exit(main(sys.argv))
