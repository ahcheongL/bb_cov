#!/usr/bin/env python3

import os, sys, json

from get_bbcov_stat import get_bb_cov


def get_line_cov(cov_fn: str) -> dict[str, dict[str, dict[int, bool]]]:
    # file -> func -> line -> covered
    bb_cov = get_bb_cov(cov_fn)
    line_cov: dict[str, dict[str, dict[int, bool]]] = {}
    for fn in bb_cov:
        line_cov[fn] = {}

        for func in bb_cov[fn]:
            line_cov[fn][func] = {}

            for bb in bb_cov[fn][func]:
                covered = bb_cov[fn][func][bb]
                # BB format: <start_line>:<end_line>_<index>

                if "_" in bb:
                    bb = bb.split("_")[0]

                if ":" not in bb:
                    continue

                start_line, end_line = bb.split(":")
                start_line = int(start_line)
                end_line = int(end_line)

                for line in range(start_line, end_line + 1):
                    if line not in line_cov[fn][func]:
                        line_cov[fn][func][line] = covered
                    else:
                        line_cov[fn][func][line] = line_cov[fn][func][line] or covered

    return line_cov


def write_line_cov(line_cov: dict[str, dict[str, dict[int, bool]]], out_fn: str):
    with open(out_fn, "w") as outf:
        json.dump(line_cov, outf, indent=2)


def main(argv):
    if len(argv) < 2:
        print(f"Usage : {argv[0]} <cov_file> [out.json]")
        print("  It interprets BB coverage output file and outputs line coverage info.")
        print("  <cov_file>: BB coverage output file generated by bb_cov_pass.")
        print(
            "  [out.json]: (Optional) Output file name to save line coverage info. If not provided, prints to stdout."
        )
        return 1

    cov_file = argv[1]
    if not os.path.exists(cov_file) or not os.path.isfile(cov_file):
        print(f"Cov file {cov_file} does not exist or is not a file")
        return 1

    output_fn = None
    if len(argv) >= 3:
        output_fn = argv[2]

    line_cov = get_line_cov(cov_file)

    if output_fn is not None:
        write_line_cov(line_cov, output_fn)
        return 0

    # Print to stdout
    for fn in line_cov:
        print(f"File {fn}")
        for func in line_cov[fn]:
            print(f"F {func}")
            for line in sorted(line_cov[fn][func].keys()):
                covered = line_cov[fn][func][line]
                cov_int = 1 if covered else 0
                print(f"L {line} {cov_int}")

    return 0


if __name__ == "__main__":
    sys.exit(main(sys.argv))
